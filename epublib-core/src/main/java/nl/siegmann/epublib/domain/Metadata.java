package nl.siegmann.epublib.domain;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.namespace.QName;

import nl.siegmann.epublib.service.MediatypeService;
import nl.siegmann.epublib.util.StringUtil;
import android.os.Parcel;
import android.os.Parcelable;

/**
 * A Book's collection of Metadata. In the future it should contain all Dublin Core attributes, for now it contains a set of often-used ones.
 * 
 * @author paul
 * 
 */
public class Metadata implements Serializable, Parcelable
{

	/**
	 * 
	 */
	private static final long serialVersionUID = -2437262888962149444L;

	public static final String DEFAULT_LANGUAGE = "en";

	private boolean autoGeneratedId = true;
	private List<Author> authors = new ArrayList<Author>();
	private List<Author> contributors = new ArrayList<Author>();
	private List<Date> dates = new ArrayList<Date>();
	private String language = DEFAULT_LANGUAGE;
	private Map<QName, String> otherProperties = new HashMap<QName, String>();
	private List<String> rights = new ArrayList<String>();
	private List<String> titles = new ArrayList<String>();
	private List<Identifier> identifiers = new ArrayList<Identifier>();
	private List<String> subjects = new ArrayList<String>();
	private String format = MediatypeService.EPUB.getName();
	private List<String> types = new ArrayList<String>();
	private List<String> descriptions = new ArrayList<String>();
	private List<String> publishers = new ArrayList<String>();
	private Map<String, String> metaAttributes = new HashMap<String, String>();

	public Metadata()
	{
		identifiers.add(new Identifier());
		autoGeneratedId = true;
	}

	/**
	 * @param source
	 */
	public Metadata(Parcel source)
	{
		autoGeneratedId = (source.readByte() == 1);
		if (source.readByte() == 1) language = source.readString();
		if (source.readByte() == 1) format = source.readString();

		if (source.readByte() == 1) source.readStringList(rights);
		if (source.readByte() == 1) source.readStringList(titles);		
		if (source.readByte() == 1) source.readStringList(subjects);
		if (source.readByte() == 1) source.readStringList(types);
		if (source.readByte() == 1) source.readStringList(descriptions);
		if (source.readByte() == 1) source.readStringList(publishers);

		if (source.readByte() == 1) source.readTypedList(authors, Author.CREATOR);
		if (source.readByte() == 1) source.readTypedList(contributors, Author.CREATOR);
		if (source.readByte() == 1) source.readTypedList(dates, Date.CREATOR);
		if (source.readByte() == 1) source.readTypedList(identifiers, Identifier.CREATOR);
		
		// metadataAttributes
		if (source.readByte() == 1) 
		{
			final ArrayList<String> keys = new ArrayList<String>();
			source.readStringList(keys);
			final ArrayList<String> values = new ArrayList<String>();
			source.readStringList(values);
			final int size = keys.size();
			metaAttributes = new HashMap<String, String>(size);
			for (int i = 0; i < size; i++)
			{
				metaAttributes.put(keys.get(i), values.get(i));
			}
		}
		
		// otherProperties
		if (source.readByte() == 1) 
		{
			final ArrayList<QNameWrapper> keys = new ArrayList<QNameWrapper>();
			source.readTypedList(keys, QNameWrapper.CREATOR);
			final ArrayList<String> values = new ArrayList<String>();
			source.readStringList(values);
			final int size = keys.size();
			otherProperties = new HashMap<QName, String>(size);
			for (int i = 0; i < size; i++)
			{
				final QNameWrapper name = keys.get(i);
				otherProperties.put(new QName(name.getNamespaceURI(), name.getLocalPart(), name.getPrefix()), values.get(i));
			}
		}
	}

	public boolean isAutoGeneratedId()
	{
		return autoGeneratedId;
	}

	/**
	 * Metadata properties not hard-coded like the author, title, etc.
	 * 
	 * @return Metadata properties not hard-coded like the author, title, etc.
	 */
	public Map<QName, String> getOtherProperties()
	{
		return otherProperties;
	}

	public void setOtherProperties(Map<QName, String> otherProperties)
	{
		this.otherProperties = otherProperties;
	}

	public Date addDate(Date date)
	{
		this.dates.add(date);
		return date;
	}

	public List<Date> getDates()
	{
		return dates;
	}

	public void setDates(List<Date> dates)
	{
		this.dates = dates;
	}

	public Author addAuthor(Author author)
	{
		authors.add(author);
		return author;
	}

	public List<Author> getAuthors()
	{
		return authors;
	}

	public void setAuthors(List<Author> authors)
	{
		this.authors = authors;
	}

	public Author addContributor(Author contributor)
	{
		contributors.add(contributor);
		return contributor;
	}

	public List<Author> getContributors()
	{
		return contributors;
	}

	public void setContributors(List<Author> contributors)
	{
		this.contributors = contributors;
	}

	public String getLanguage()
	{
		return language;
	}

	public void setLanguage(String language)
	{
		this.language = language;
	}

	public List<String> getSubjects()
	{
		return subjects;
	}

	public void setSubjects(List<String> subjects)
	{
		this.subjects = subjects;
	}

	public void setRights(List<String> rights)
	{
		this.rights = rights;
	}

	public List<String> getRights()
	{
		return rights;
	}

	/**
	 * Gets the first non-blank title of the book. Will return "" if no title found.
	 * 
	 * @return the first non-blank title of the book.
	 */
	public String getFirstTitle()
	{
		if (titles == null || titles.isEmpty())
		{
			return "";
		}
		for (String title : titles)
		{
			if (StringUtil.isNotBlank(title))
			{
				return title;
			}
		}
		return "";
	}

	public String addTitle(String title)
	{
		this.titles.add(title);
		return title;
	}

	public void setTitles(List<String> titles)
	{
		this.titles = titles;
	}

	public List<String> getTitles()
	{
		return titles;
	}

	public String addPublisher(String publisher)
	{
		this.publishers.add(publisher);
		return publisher;
	}

	public void setPublishers(List<String> publishers)
	{
		this.publishers = publishers;
	}

	public List<String> getPublishers()
	{
		return publishers;
	}

	public String addDescription(String description)
	{
		this.descriptions.add(description);
		return description;
	}

	public void setDescriptions(List<String> descriptions)
	{
		this.descriptions = descriptions;
	}

	public List<String> getDescriptions()
	{
		return descriptions;
	}

	public Identifier addIdentifier(Identifier identifier)
	{
		if (autoGeneratedId && (!(identifiers.isEmpty())))
		{
			identifiers.set(0, identifier);
		}
		else
		{
			identifiers.add(identifier);
		}
		autoGeneratedId = false;
		return identifier;
	}

	public void setIdentifiers(List<Identifier> identifiers)
	{
		this.identifiers = identifiers;
		autoGeneratedId = false;
	}

	public List<Identifier> getIdentifiers()
	{
		return identifiers;
	}

	public void setFormat(String format)
	{
		this.format = format;
	}

	public String getFormat()
	{
		return format;
	}

	public String addType(String type)
	{
		this.types.add(type);
		return type;
	}

	public List<String> getTypes()
	{
		return types;
	}

	public void setTypes(List<String> types)
	{
		this.types = types;
	}

	public String getMetaAttribute(String name)
	{
		return metaAttributes.get(name);
	}

	public void setMetaAttributes(Map<String, String> metaAttributes)
	{
		this.metaAttributes = metaAttributes;
	}

	/// Parcelable
	@Override
	public int describeContents()
	{
		return 0;
	}

	@Override
	public void writeToParcel(Parcel dest, int flags)
	{
		dest.writeByte((byte)(autoGeneratedId ? 1 : 0));
		dest.writeByte((byte)(language != null ? 1 : 0));
		if (language != null) dest.writeString(language);
		dest.writeByte((byte)(format != null ? 1 : 0));
		if (format != null) dest.writeString(format);
		
		dest.writeByte((byte)(rights != null ? 1 : 0));
		if (rights != null) dest.writeStringList(rights);
		dest.writeByte((byte)(titles != null ? 1 : 0));
		if (titles != null) dest.writeStringList(titles);
		dest.writeByte((byte)(subjects != null ? 1 : 0));
		if (subjects != null) dest.writeStringList(subjects);
		dest.writeByte((byte)(types != null ? 1 : 0));
		if (types != null) dest.writeStringList(types);
		dest.writeByte((byte)(descriptions != null ? 1 : 0));
		if (descriptions != null) dest.writeStringList(descriptions);
		dest.writeByte((byte)(publishers != null ? 1 : 0));
		if (publishers != null) dest.writeStringList(publishers);

		dest.writeByte((byte)(authors != null ? 1 : 0));
		if (authors != null) dest.writeTypedList(authors);
		dest.writeByte((byte)(contributors != null ? 1 : 0));
		if (contributors != null) dest.writeTypedList(contributors);
		dest.writeByte((byte)(dates != null ? 1 : 0));
		if (dates != null) dest.writeTypedList(dates);
		dest.writeByte((byte)(identifiers != null ? 1 : 0));
		if (identifiers != null) dest.writeTypedList(identifiers);
		
		/// write maps as list of keys + list of values
//		Arrays.asList(otherProperties.keySet().toArray(new QName[otherProperties.size()]));
		// metaAttributes
		dest.writeByte((byte)(metaAttributes != null ? 1 : 0));
		if (metaAttributes != null) 
		{
			final int size = metaAttributes.size();
			dest.writeStringList(Arrays.asList(metaAttributes.keySet().toArray(new String[size])));
			dest.writeStringList(Arrays.asList(metaAttributes.values().toArray(new String[size])));
		}
		
		// otherProperties
		dest.writeByte((byte)(otherProperties != null ? 1 : 0));
		if (otherProperties != null) 
		{
			final int size = otherProperties.size();
			final ArrayList<QNameWrapper> keys = new ArrayList<QNameWrapper>(size);
			final ArrayList<String> values = new ArrayList<String>(size);
			for (final QName name : otherProperties.keySet())
			{
				keys.add(new QNameWrapper(name.getNamespaceURI(), name.getLocalPart(), name.getPrefix()));
				values.add(otherProperties.get(name));
			}
			dest.writeTypedList(keys);
			dest.writeStringList(values);
		}
	}

	public static final Parcelable.Creator<Metadata> CREATOR = new Parcelable.Creator<Metadata>()
	{
		@Override
		public Metadata createFromParcel(Parcel source)
		{
			return new Metadata(source);
		}

		@Override
		public Metadata[] newArray(int size)
		{
			return new Metadata[size];
		}
	};
}
